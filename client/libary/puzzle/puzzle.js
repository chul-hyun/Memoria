/**
 * The MIT License (MIT)
 * Copyright (c) 2014 람츠 qkrcjfgus3@gmail.com
 * https://github.com/qkrcjfgus33/Puzzle.js
 */

"use strict";(function(factory){if(typeof exports==='object'){module.exports=factory()}else if(typeof define==='function'&&define.amd){define(factory)}else{window.puzzle=factory()}})(function(){var puzzle={},pieces={}var DEFALUT_PROP_OPTION={'init':undefined,'apply':undefined,'lazyApply':true,'private':false}var DEFALUT_PROP_PUBLIC={'value':undefined,'old':undefined,'todoApply':false,'apply':undefined,'lazyApply':undefined}var DEFALUT_PROP_PRIVATE={'dependencePropNames':[],'dependentPropInfos':[],'apply':function(){},'private':false}var DEFALUT_CONNECT_OPTION={'propName':undefined,'private':false,'lazyApply':undefined}var getPID=(function(){var id=0 return function(){return id++}})();function piece(configFn){var constructors=function(){var ID=getPID(),pieceOptions={},pieceConfig={},piece=pieces[ID]={},propValues=piece.values={},propInfo=piece.info={},initFn=undefined,that=this pieceConfig={$connect:function(connectPuzzle,connects){for(var connectPropName in connects){var connectOption=connects[connectPropName]if(isString(connectOption)){if(isInt(connectPropName)){connectPropName=connectOption}connectOption={propName:connectOption}}initObj(DEFALUT_CONNECT_OPTION,connectOption)var connectPiece=pieces[connectPuzzle.$$getID()]connectObj(connectPuzzle,connectPropName,propValues,connectOption.propName);connectObj(connectPiece.info,connectPropName,propInfo,connectOption.propName);if(connectOption.lazyApply!=undefined){connectPuzzle.$getConnector(connectPropName).lazyApply=connectOption.lazyApply}if(!connectOption.private){connectObj(connectPuzzle,connectPropName,that,connectOption.propName)}}},$setPiece:function(options){pieceOptions=options}}initFn=configFn.apply(pieceConfig,arguments)config.apply(this)if(typeof initFn=="function"){initFn.apply(propValues)}function config(){initOption(pieceOptions)for(var propName in pieceOptions){initPropInfo(propInfo,propName)}for(var propName in pieceOptions){registObserve(propInfo,propValues,propName,pieceOptions[propName]);if(!propInfo[propName].$$.private){connectObj(propValues,propName,this)}}for(var propName in pieceOptions){propValues[propName]=pieceOptions[propName].init}for(var propName in pieceOptions){if(!propInfo[propName].$$.private){connectObj(propValues,propName,this)}}}this.$forceApply=function(name){if(name){var p_public=propInfo[name].$,p_private=propInfo[name].$$ p_public.todoApply=true}else{for(var propName in propInfo){this.$forceApply(propName)}}}this.$getConnector=function(name){return propInfo[name].$}this.$apply=function(name){if(name){var p_public=propInfo[name].$,p_private=propInfo[name].$$ if(p_public.todoApply){p_public.todoApply=false p_private.apply()}}}this.$$getID=function(){return ID}}return constructors}function initOption(pieceOptions){for(var propName in pieceOptions){var pieceOption=pieceOptions[propName]if(isFunction(pieceOption)){var apply=pieceOption pieceOption={}pieceOption.apply=apply}else if(!isObject(pieceOption)){var init=clone(pieceOption)pieceOption={}pieceOption.init=init}initObj(DEFALUT_PROP_OPTION,pieceOption)pieceOptions[propName]=pieceOption}}function registObserve(propInfo,propValues,propName,pieceOption){var prop=propInfo[propName],p_public=prop.$,p_private=prop.$$ defineObserve(p_public,'value',clone(observeValue))defineObserve(p_public,'todoApply',clone(observeTodoApply))defineObserve(p_public,'lazyApply',clone(observeLazyApply))defineObserve(p_public,'apply',clone(observeApply))syncGetAndSet(propValues,propInfo,propName)p_private.private=pieceOption.private p_public.lazyApply=pieceOption.lazyApply p_public.apply=pieceOption.apply function observeTodoApply(newValue){if(newValue&&!p_public.lazyApply){p_public.todoApply=false p_private.apply()}}function observeLazyApply(newValue){if(p_public.todoApply&&!newValue){p_public.todoApply=false p_private.apply()}}function observeValue(newValue){p_public.old=p_public.value}function observeApply(newValue){var dependencePropNames=p_private.dependencePropNames var propIsConnectedDependentProp=false for(var i=0,len=dependencePropNames.length;i<len;i++){var applyArgName=dependencePropNames[i],d_private=propInfo[applyArgName].$$ removeArrayItem(d_private.dependentPropInfos,propName)}p_private.dependencePropNames=dependencePropNames=getArg(newValue);for(var i=0,len=dependencePropNames.length;i<len;i++){var applyArgName=dependencePropNames[i],d_private=propInfo[applyArgName].$$,d_public=propInfo[applyArgName].$ d_private.dependentPropInfos.push(prop)if(!propIsConnectedDependentProp&&d_public.todoApply){propIsConnectedDependentProp=true}}if(newValue===undefined){p_private.apply=function(){};return}p_private.apply=(function(){var dependencePropNames=p_private.dependencePropNames return function(){var applyArgs=[]for(var i=0,len=dependencePropNames.length;i<len;i++){applyArgName=dependencePropNames[i]applyArgs[i]=propValues[applyArgName]}propValues[propName]=(newValue).apply(propValues,applyArgs)}})();if(propIsConnectedDependentProp){p_public.todoApply=true}}}function syncGetAndSet(propValues,propInfo,propName){var prop=propInfo[propName],p_public=prop.$,p_private=prop.$$ var getter,setter;getter=function(){if(p_public.todoApply){p_public.todoApply=false;p_private.apply()}return p_public.value}setter=function(newval){p_public.value=newval dependentTodoApply(p_private.dependentPropInfos)}defineGetAndSet(propValues,propName,clone(getter),clone(setter))}function dependentTodoApply(dependentPropInfos){for(var i=0,len=dependentPropInfos.length;i<len;i++){var dependentProp=dependentPropInfos[i]dependentProp.$.todoApply=true if(dependentProp.$.lazyApply){dependentTodoApply(dependentProp.$$.dependentPropInfos)}}}function initPropInfo(propInfo,propName){var prop=propInfo[propName]=(propInfo[propName]===undefined)?{}:propInfo[propName];prop.$=(prop.$===undefined)?clone(DEFALUT_PROP_PUBLIC):prop.$ prop.$$=(prop.$$===undefined)?clone(DEFALUT_PROP_PRIVATE):prop.$$}var STRIP_COMMENTS=/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg var FN_ARGS=/^function\s*[^\(]*\(\s*([^\)]*)\)/m function getArg(fn){if(fn===undefined){return[]}var fnText=fn.toString().replace(STRIP_COMMENTS,'')var argDecl=fnText.match(FN_ARGS)var argStr=(argDecl[1]).replace(/\s/g,'')if(argStr==''){return[]}return argStr.split(',')}function removeArrayItem(arr,item){var index=arr.indexOf(item)if(index!==-1){fruits.splice(index,1)}}function defineGetAndSet(obj,propName,getter,setter){try{Object.defineProperty(obj,propName,{get:getter,set:setter,enumerable:true,configurable:true})}catch(e2){try{Object.prototype.__defineGetter__.call(obj,propName,getter)Object.prototype.__defineSetter__.call(obj,propName,setter)}catch(e3){throw new Error("PuzzleJS error: browser not supported :/")}}}function defineObserve(obj,propName,observeFn){return(function(observeFn){var value=obj[propName]var getter=function(){return value}var setter=function(newValue){if(value!==newValue){observeFn.call(obj,newValue)value=newValue}}defineGetAndSet(obj,propName,getter,setter)return function(){value=observeFn.call(obj,obj[propName])}})(observeFn)}function connectObj(sourceObj,sourcePropName,obj,propName){propName=(propName===undefined)?sourcePropName:propName defineGetAndSet(obj,propName,function(){return sourceObj[sourcePropName]},function(newValue){sourceObj[sourcePropName]=newValue})}function initObj(defaultObj,targetObj){for(var prop in defaultObj){targetObj[prop]=(targetObj[prop]===undefined)?clone(defaultObj[prop]):targetObj[prop]if(targetObj[prop]=='__require__'){throw Error("필수값이 입력되지 않았습니다.")}}}function clone(obj){var clonedObjectsArray=[]var originalObjectsArray=[]var next_objid=0 function objectId(obj){if(obj==null)return null if(obj.__obj_id==undefined){obj.__obj_id=next_objid++originalObjectsArray[obj.__obj_id]=obj}return obj.__obj_id}function cloneRecursive(obj){if(null==obj||typeof obj=="string"||typeof obj=="number"||typeof obj=="boolean")return obj if(obj instanceof Date){var copy=new Date()copy.setTime(obj.getTime())return copy}if(obj instanceof Array){var copy=[]for(var i=0;i<obj.length;++i){copy[i]=cloneRecursive(obj[i])}return copy}if(obj instanceof Object){if(clonedObjectsArray[objectId(obj)]!=undefined)return clonedObjectsArray[objectId(obj)]var copy;if(obj instanceof Function)copy=function(){return obj.apply(this,arguments)}else copy={}clonedObjectsArray[objectId(obj)]=copy for(var attr in obj)if(attr!="__obj_id"&&obj.hasOwnProperty(attr))copy[attr]=cloneRecursive(obj[attr])return copy}throw new Error("Unable to copy obj! Its type isn't supported.")}var cloneObj=cloneRecursive(obj)for(var i=0;i<originalObjectsArray.length;i++){delete originalObjectsArray[i].__obj_id}return cloneObj}function isFunction(value){return typeof value==='function'}function isObject(value){return value!=null&&typeof value==='object'}function isString(value){return typeof value=='string'||value instanceof String}function isInt(n){return n%1===0}function EmptyFunction(){}puzzle.piece=piece return puzzle})